# C++设计模式 GeeBand

---
[侯捷老师C++设计模式](https://www.bilibili.com/video/av59120504)

---

## 0. 深入理解面向对象
向下：深入理解三大面向对象机制
• 封装，隐藏内部实现
• 继承，复用现有代码
• 多态，改写对象行为

向上：深刻把握面向对象机制所带来的抽象意义，理解如何使用
这些机制来表达现实世界，掌握什么是“好的面向对象设计”


## 1. 如何解决复杂性？
**分解**
• 人们面对复杂性有一个常见的做法：即分而治之，将大问题分
解为多个小问题，将复杂问题分解为多个简单问题。
**抽象**
• 更高层次来讲，人们处理复杂性有一个通用的技术，即抽象。
由于不能掌握全部的复杂对象，我们选择忽视它的非本质细节，
而去处理泛化和理想化了的对象模型。


## 2. 面向对象设计原则
**依赖倒置原则（DIP）**
• 高层模块(稳定)不应该依赖于低层模块(变化)，二者都应该依赖
于抽象(稳定) 。
• 抽象(稳定)不应该依赖于实现细节(变化) ，实现细节应该依赖于
抽象(稳定)。

**开放封闭原则（OCP）**
• 对扩展开放，对更改封闭。
• 类模块应该是可扩展的，但是不可修改。

**单一职责原则（SRP）**
• 一个类应该仅有一个引起它变化的原因。
• 变化的方向隐含着类的责任。

**Liskov 替换原则（LSP）**
• 子类必须能够替换它们的基类(IS-A)。
• 继承表达类型抽象。

**接口隔离原则（ISP）**
• 不应该强迫客户程序依赖它们不用的方法。
• 接口应该小而完备。

**优先使用对象组合，而不是类继承**
• 类继承通常为“白箱复用”，对象组合通常为“黑箱复用” 。
• 继承在某种程度上破坏了封装性，子类父类耦合度高。
• 而对象组合则只要求被组合的对象具有良好定义的接口，耦合
度低。

**封装变化点**
• 使用封装来创建对象之间的分界层，让设计者可以在分界层的
一侧进行修改，而不会对另一侧产生不良的影响，从而实现层
次间的松耦合。

**针对接口编程，而不是针对实现编程**
• 不将变量类型声明为某个特定的具体类，而是声明为某个接口。
• 客户程序无需获知对象的具体类型，只需要知道对象所具有的
接口。
• 减少系统中各部分的依赖关系，从而实现“高内聚、松耦合”
的类型设计方案。

## 3. 模式分类
**从目的来看：**
• 创建型（Creational）模式：将对象的部分创建工作延迟到子
类或者其他对象，从而应对需求变化为对象创建时具体类型实
现引来的冲击。
• 结构型（Structural）模式：通过类继承或者对象组合获得更灵
活的结构，从而应对需求变化为对象的结构带来的冲击。
• 行为型（Behavioral）模式：通过类继承或者对象组合来划分
类与对象间的职责，从而应对需求变化为多个交互的对象带来
的冲击。

**从范围来看：**
• 类模式处理类与子类的静态关系。
• 对象模式处理对象间的动态关系。

## 4. 重构关键技法
- 静态 -> 动态
- 早绑定 -> 晚绑定
- 继承 -> 组合
- 编译时依赖 -> 运行时依赖
- 紧耦合 -> 松耦合

## 5. “组件协作”模式:
- 现代软件专业分工之后的第一个结果是“框架与应用程序的划
分”，“组件协作”模式通过晚期绑定，来实现框架与应用程序之
间的松耦合，是二者之间协作时常用的模式。
- 典型模式
• Template Method
• Observer / Event
• Strategy

### 5.1 Template Method
定义一个操作中的算法的骨架 (稳定)，而将一些步骤延迟
(变化)到子类中。 Template Method使得子类可以不改变
(复用)一个算法的结构即可重定义(override 重写)该算法的
某些特定步骤。

- Template Method模式是一种非常基础性的设计模式，在面向对
象系统中有着大量的应用。它用最简洁的机制（虚函数的多态性）
为很多应用程序框架提供了灵活的扩展点，是代码复用方面的基本
实现结构。
- 除了可以灵活应对子步骤的变化外，“不要调用我，让我来调用
你”的反向控制结构是Template Method的典型应用。
- 在具体实现方面，被Template Method调用的虚方法可以具有实
现，也可以没有任何实现（抽象方法、纯虚方法），但一般推荐将
它们设置为protected方法。


## 7. “对象创建”模式:
- 通过“对象创建” 模式绕开new，来避免对象创建（new）过程
中所导致的紧耦合（依赖具体类），从而支持对象创建的稳定。它
是接口抽象之后的第一步工作。
- 典型模式
•Factory Method
•Abstract Factory
•Prototype
•Builder

### 7.1 Factory Method 工厂方法
定义一个用于创建对象的接口，让子类决定实例化哪一个类。
Factory Method使得一个类的实例化延迟（目的：解耦，
手段：虚函数）到子类

- Factory Method模式用于隔离类对象的使用者和具体类型之间的
耦合关系。面对一个经常变化的具体类型，紧耦合关系(new)会导
致软件的脆弱。
- Factory Method模式通过面向对象的手法，将所要创建的具体对
象工作延迟到子类，从而实现一种扩展（而非更改）的策略，较好
地解决了这种紧耦合关系。
- Factory Method模式解决“单个对象”的需求变化。缺点在于要
求创建方法/参数相同

### 7.2 Abstract Factory 抽象工厂
提供一个接口，让该接口负责创建一系列“相关或者相互依
赖的对象”，无需指定它们具体的类。

*也许 `Family Factory`是比`Abstract Factory`一个更合适的名字*

- 如果没有应对“多系列对象构建”的需求变化，则没有必要使用
Abstract Factory模式，这时候使用简单的工厂完全可以。
- “系列对象”指的是在某一特定系列下的对象之间有相互依赖、
或作用的关系。不同系列的对象之间不能相互依赖。
- Abstract Factory模式主要在于应对“新系列”的需求变动。其缺
点在于难以应对“新对象”的需求变动。


## 8. "对象性能"模式:
- 典型模式
•Singleton
•Flyweight

### 8.1 Singleton 单例模式
保证一个类只有一个实例，并提供一个该实例的全局访问点。
- Singleton模式中的实例构造器可以设置为protected以允许子类派生。
- Singleton模式一般不要支持拷贝构造函数和复制接口， 因为可能导致多个对象实例，与Singleton的初衷相悖。

# C++设计模式 GeeBand

---
[侯捷老师C++设计模式](https://www.bilibili.com/video/av59120504)

---

## 0. 深入理解面向对象
向下：深入理解三大面向对象机制
• 封装，隐藏内部实现
• 继承，复用现有代码
• 多态，改写对象行为

向上：深刻把握面向对象机制所带来的抽象意义，理解如何使用
这些机制来表达现实世界，掌握什么是“好的面向对象设计”


## 1. 如何解决复杂性？
**分解**
• 人们面对复杂性有一个常见的做法：即分而治之，将大问题分
解为多个小问题，将复杂问题分解为多个简单问题。
**抽象**
• 更高层次来讲，人们处理复杂性有一个通用的技术，即抽象。
由于不能掌握全部的复杂对象，我们选择忽视它的非本质细节，
而去处理泛化和理想化了的对象模型。


## 2. 八大面向对象设计原则
**依赖倒置原则（DIP）**
• 高层模块(稳定)不应该依赖于低层模块(变化)，二者都应该依赖
于抽象(稳定) 。
• 抽象(稳定)不应该依赖于实现细节(变化) ，实现细节应该依赖于
抽象(稳定)。

**开放封闭原则（OCP）**
• 对扩展开放，对更改封闭。
• 类模块应该是可扩展的，但是不可修改。

**单一职责原则（SRP）**
• 一个类应该仅有一个引起它变化的原因。
• 变化的方向隐含着类的责任。

**Liskov 替换原则（LSP）**
• 子类必须能够替换它们的基类(IS-A)。
• 继承表达类型抽象。

**接口隔离原则（ISP）**
• 不应该强迫客户程序依赖它们不用的方法。
• 接口应该小而完备。

**优先使用对象组合，而不是类继承**
• 类继承通常为“白箱复用”，对象组合通常为“黑箱复用” 。
• 继承在某种程度上破坏了封装性，子类父类耦合度高。
• 而对象组合则只要求被组合的对象具有良好定义的接口，耦合
度低。

**封装变化点**
• 使用封装来创建对象之间的分界层，让设计者可以在分界层的
一侧进行修改，而不会对另一侧产生不良的影响，从而实现层
次间的松耦合。

**针对接口编程，而不是针对实现编程**
• 不将变量类型声明为某个特定的具体类，而是声明为某个接口。
• 客户程序无需获知对象的具体类型，只需要知道对象所具有的
接口。
• 减少系统中各部分的依赖关系，从而实现“高内聚、松耦合”
的类型设计方案。

## 3. 模式分类
**从目的来看：**
• 创建型（Creational）模式：将对象的部分创建工作延迟到子
类或者其他对象，从而应对需求变化为对象创建时具体类型实
现引来的冲击。
• 结构型（Structural）模式：通过类继承或者对象组合获得更灵
活的结构，从而应对需求变化为对象的结构带来的冲击。
• 行为型（Behavioral）模式：通过类继承或者对象组合来划分
类与对象间的职责，从而应对需求变化为多个交互的对象带来
的冲击。

**从范围来看：**
• 类模式处理类与子类的静态关系。
• 对象模式处理对象间的动态关系。

## 4. 重构关键技法
- 静态 -> 动态
- 早绑定 -> 晚绑定
- 继承 -> 组合
- 编译时依赖 -> 运行时依赖
- 紧耦合 -> 松耦合

## 5 “组件协作”模式:
- 现代软件专业分工之后的第一个结果是“框架与应用程序的划
分”，“组件协作”模式通过晚期绑定，来实现框架与应用程序之
间的松耦合，是二者之间协作时常用的模式。
- 典型模式
• Template Method
• Observer / Event
• Strategy

#### 5.1 Template Method
定义一个操作中的算法的骨架 (稳定)，而将一些步骤延迟
(变化)到子类中。 Template Method使得子类可以不改变
(复用)一个算法的结构即可重定义(override 重写)该算法的
某些特定步骤。

- Template Method模式是一种非常基础性的设计模式，在面向对
象系统中有着大量的应用。它用最简洁的机制（虚函数的多态性）
为很多应用程序框架提供了灵活的扩展点，是代码复用方面的基本
实现结构。
- 除了可以灵活应对子步骤的变化外，“不要调用我，让我来调用
你”的反向控制结构是Template Method的典型应用。
- 在具体实现方面，被Template Method调用的虚方法可以具有实
现，也可以没有任何实现（抽象方法、纯虚方法），但一般推荐将
它们设置为protected方法。


#### 5.2 Strategy 策略模式
定义一系列算法，把它们一个个封装起来，并且使它们可互
相替换（变化）。该模式使得算法可独立于使用它的客户程
序(稳定)而变化（扩展，子类化）。

- Strategy及其子类为组件提供了一系列可重用的算法，从而可以使
得类型在运行时方便地根据需要在各个算法之间进行切换。
- Strategy模式提供了用条件判断语句以外的另一种选择，消除条件
判断语句，就是在解耦合。含有许多条件判断语句的代码通常都需
要Strategy模式。
- 如果Strategy对象没有实例变量，那么各个上下文可以共享同一个
Strategy对象，从而节省对象开销。


#### 5.3 Observer 观察者模式
定义对象间的一种一对多（变化）的依赖关系，以便当一个
对象(Subject)的状态发生改变时，所有依赖于它的对象都
得到通知并自动更新。

- 使用面向对象的抽象，Observer模式使得我们可以独立地改变目
标与观察者，从而使二者之间的依赖关系达致松耦合。
- 目标发送通知时，无需指定观察者，通知（可以携带通知信息作
为参数）会自动传播。
- 观察者自己决定是否需要订阅通知，目标对象对此一无所知。
- Observer模式是基于事件的UI框架中非常常用的设计模式，也是
MVC模式的一个重要组成部分。

## 6 “单一职责”模式:
- 在软件组件的设计中，如果责任划分的不清晰，使用继承得到的
结果往往是随着需求的变化，子类急剧膨胀，同时充斥着重复代码，
这时候的关键是划清责任。
- 典型模式
• Decorator
• Bridge

#### 6.1 Decorator 装饰模式
动态（组合）地给一个对象增加一些额外的职责。就增加功
能而言，Decorator模式比生成子类（继承）更为灵活（消
除重复代码 & 减少子类个数）。

- 通过采用组合而非继承的手法， Decorator模式实现了在运行时
动态扩展对象功能的能力，而且可以根据需要扩展多个功能。避免
了使用继承带来的“灵活性差”和“多子类衍生问题”。
- Decorator类在接口上表现为is-a Component的继承关系，即
Decorator类继承了Component类所具有的接口。但在实现上又
表现为has-a Component的组合关系，即Decorator类又使用了
另外一个Component类。
- Decorator模式的目的并非解决“多子类衍生的多继承”问题，
Decorator模式应用的要点在于解决“主体类在多个方向上的扩展
功能”——是为“装饰”的含义。

#### 6.2 Bridge 桥模式
将抽象部分(业务功能)与实现部分(平台实现)分离，使它们
都可以独立地变化。

- Bridge模式使用“对象间的组合关系”解耦了抽象和实现之间固
有的绑定关系，使得抽象和实现可以沿着各自的维度来变化。所谓
抽象和实现沿着各自纬度的变化，即“子类化”它们。
- Bridge模式有时候类似于多继承方案，但是多继承方案往往违背
单一职责原则（即一个类只有一个变化的原因），复用性比较差。
Bridge模式是比多继承方案更好的解决方法。
- Bridge模式的应用一般在“两个非常强的变化维度”，有时一个
类也有多于两个的变化维度，这时可以使用Bridge的扩展模式。


## 7 “对象创建”模式:
- 通过“对象创建” 模式绕开new，来避免对象创建（new）过程
中所导致的紧耦合（依赖具体类），从而支持对象创建的稳定。它
是接口抽象之后的第一步工作。
- 典型模式
•Factory Method
•Abstract Factory
•Prototype
•Builder

#### 7.1 Factory Method 工厂方法
定义一个用于创建对象的接口，让子类决定实例化哪一个类。
Factory Method使得一个类的实例化延迟（目的：解耦，
手段：虚函数）到子类

- Factory Method模式用于隔离类对象的使用者和具体类型之间的
耦合关系。面对一个经常变化的具体类型，紧耦合关系(new)会导
致软件的脆弱。
- Factory Method模式通过面向对象的手法，将所要创建的具体对
象工作延迟到子类，从而实现一种扩展（而非更改）的策略，较好
地解决了这种紧耦合关系。
- Factory Method模式解决“单个对象”的需求变化。缺点在于要
求创建方法/参数相同

#### 7.2 Abstract Factory 抽象工厂
提供一个接口，让该接口负责创建一系列“相关或者相互依
赖的对象”，无需指定它们具体的类。

*也许 `Family Factory`是比`Abstract Factory`一个更合适的名字*

- 如果没有应对“多系列对象构建”的需求变化，则没有必要使用
Abstract Factory模式，这时候使用简单的工厂完全可以。
- “系列对象”指的是在某一特定系列下的对象之间有相互依赖、
或作用的关系。不同系列的对象之间不能相互依赖。
- Abstract Factory模式主要在于应对“新系列”的需求变动。其缺
点在于难以应对“新对象”的需求变动。

#### 7.3 prototype 原型模式
使用原型实例指定创建对象的种类，然后通过拷贝这些原型来创建新的对象。


#### 7.4 Builder 构建器
将一个复杂对象的构建与其表示相分离，使得同样的构建过
程(稳定)可以创建不同的表示(变化)。
- Builder 模式主要用于“分步骤构建一个复杂的对象”。在这其中
“分步骤”是一个稳定的算法，而复杂对象的各个部分则经常变化。
- 变化点在哪里，封装哪里—— Builder模式主要在于应对“复杂对
象各个部分”的频繁需求变动。其缺点在于难以应对“分步骤构建
算法”的需求变动。
- 在Builder模式中，要注意不同语言中构造器内调用虚函数的差别
（C++ vs. C#) 。


## 8 "对象性能"模式:
- 典型模式
•Singleton
•Flyweight

#### 8.1 Singleton 单例模式
保证一个类只有一个实例，并提供一个该实例的全局访问点。
- Singleton模式中的实例构造器可以设置为protected以允许子类派生。
- Singleton模式一般不要支持拷贝构造函数和复制接口， 因为可能导致多个对象实例，与Singleton的初衷相悖。

#### 8.2 Flyweight 享元模式
运用共享技术有效地支持大量细粒度的对象

## 9 "接口隔离"模式:
在组件构建过程中，某些接口之间直接的依赖常常会带来更多问题、甚至根本无法实现。采用添加一层间接（稳定）接口，来隔离
本来互相紧密关联的接口是一种常见的解决方案。
- 典型模式
•Facade
•Proxy
•Adapter
•Mediator

##### 9.1 Facade 门面模式
为子系统中的一组接口提供一个一致（稳定）的界面，Facade定义了一个高层接口，该接口使得这一子系统更加容易使用（复用）

#### 9.2 Proxy 代理模式
为其他对象提供一种代理以控制（隔离，使用接口）对这个对象的访问。

#### 9.3 Adapter 适配器模式
将一个类的接口转换成客户希望的另一个接口。 Adapter使得原本由于借口不兼容而不能一起工作的哪些类可以一起工作。

